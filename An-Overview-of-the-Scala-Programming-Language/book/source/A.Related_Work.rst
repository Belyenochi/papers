10 相关研究（Related Work）
---------------------------

Scala 的设计受到多种语言及相关论文的影响，下面列出的是对 Scala
的设计产生主要影响的一些相关研究。

显而易见地，Scala 从 Java [23] 和 C# [15]
中吸收了大量概念和语法约定。Scala 表达属性的方式，大致借鉴了Sather 语言
[44] 的模型。Scala 的统一对象模型，主要来自于 SmallTalk [22] 的概念。从
Beta [30] 语言中，Scala 借鉴了一切皆可嵌套的理念，包括类。Scala
的混入模型设计，主要来自于面向对象的线性混入[6]，但是将混入式构成定义成为对称模式，更接近于
[14, 25, 49] 中定义的混入模块，或者 traits [42]。 Scala
的抽象类型定义非常接近 ML [24] 和 OCaml [29]
当中模块体系的抽象类型签名，但将其进一步泛化成一等语法组件。
For-comprehensions 是基于 Haskell 的m onad comprehensions
[46]，尽管语法上更接近 XQuery [3]。视图主要是借鉴 Haskell 的 type
classes [47]，可以看做是面向对象版本的类型化 type classes
[38]，不过却更具通用性，因为其实例的声明是有范围的/局部的。
在动态类型系统里，视图的主要好处来自于 Classbox 的概念，不过 Classbox
比视图更强大，允许本地重绑定，从而可以通过动态指派来选择类的特定扩展。

某种意义上讲，Scala 是 Pizza 语言[37] 相关工作的一个延续（Pizza 也是
Odersky 发明的语言，接近于是 Scala 前身——译注）。和 Pizza 一样，Scala
编译后在 JVM 上运行，增加了高阶函数，泛型和模式匹配等函数式编程的构造。
区别之处在于 Pizza 还向后兼容 Java，而 Scala
的目标则是只保留互操作性，这样在设计方面就有更大的自由度。

Scala
的目标是为组件的抽象和构成提供先进的语法构造，这一点在很多最近的研究中也都有体现。抽象类型就相当于
gbeta [16, 17] 中虚拟类（virtual
classes）的一个保守实现，提供了其带来的大部分好处。 类似的还有 FamilyJ
[40] 中的代理层，以及 [32] 中提出的 Java 的嵌套继承等。Jiazzi [31] 是
Java
的一个扩展，提出了基于单元的模块化机制，这是一个强大的参数化模块形式的实现。
Jazzi 支持类似于 Scala 的语法扩展方式，例如实现 minxin 的能力。

Nice 语言 [4] 也是最近出现的一个类似于 Scala 的语言，但是从 ML<= [5]
继承了一些内容。Nice 包含了多路指派（multiple dispatch）、开放类（open
classes）以及一个基于抽象接口实现的受限形态的可追溯抽象模式。Nice
不支持模块化的实现阶段类型检查。Nice 和 Scala 虽然都与 Java
有很大差异，但都被设计为与 Java 程序和类库具有互操作性，并且也都编译成
JVM 上执行。

MultiJava [13] 是一个 Java 的保守扩展，也增加了对称多路指派和开放类。
他采用了很多不同的解决方案来实现 Scala
解决的问题。例如：多路指派就解决了二元操作方法的问题，而 Scala
是通过抽象类型解决的。又如开放类则解决了外部可扩展性问题，而 Scala
使通过视图来解决的。 MultiJava
可以动态为一个类增加新方法，这是因为开放类是基于 Java
的动态装载机制实现的，这一点是 Scala 所没有的。 反过来，也只有 Scala
才支持对类的外部扩展限定可见范围。

OCaml 和 Moby [20]
是另外两个将函数式和面向对象模式进行整合的静态类型语言。与 Scala
不同之处在于，这两种语言都是基于一套丰富的函数式编程语言和复杂的模块化系统，然后建立起相对轻量级的对象体系。
